"""
This module acts as a bridge between a Django server and a Duck server. It allows Django to handle requests that are originally meant for the Duck server.

Here's how it works:

1. **Client sends a request:** The client initiates a request to the Duck server.
2. **Duck server receives request:** The Duck server receives the request first.
3. **Request forwarded to Django:** The Duck server forwards the request to the Django server on the same network.
4. **Django processes request:** Django handles the request as if the route was defined within Duck urls.py or in Django itself.
5. **Response sent to client:** The response generated by Django is sent back to the client.
"""
import os
import subprocess

from pathlib import Path
from functools import lru_cache

from duck.settings import SETTINGS
from duck.logging import logger
from duck.utils.importer import import_module_once
from duck.cli import add_to_pythonpath


# Attempt to import the local Django duck app module
try:
    django_settings_module = import_module_once(SETTINGS['DJANGO_SETTINGS_MODULE'])
except (ImportError, KeyError, ModuleNotFoundError):
    raise ImportError(
        "Please make sure that the Django project structure for Duck is correct and DUCK_SETTINGS_MODULE is set correctly."
    )


@lru_cache(maxsize=1)
def find_manage_py() -> str:
    """
    Traveses the Django project directory and returns the final absolute path for `manage.py`.
    """
    settings_path = django_settings_module.__file__ or django_settings_module.__path__._path[0]
    settings_dir = Path(settings_path).parent

    # Traverse upward to find manage.py
    current_dir = settings_dir
    max_up = 5  # prevent infinite loop
    
    for _ in range(max_up):
        candidate = os.path.join(current_dir, "manage.py")
        if os.path.isfile(candidate):
            return candidate
        current_dir = os.path.dirname(current_dir)  # go up one level
    raise FileNotFoundError("manage.py not found within reasonable directory traversal.")


def run_django_app_commands():
    """
    Executes essential Django management commands, usually makemigrations, migrate, and collectstatic.

    This function ensures that the Django application is properly set up with
    the latest database schema and static files.
    """
    commands = SETTINGS["DJANGO_COMMANDS_ON_STARTUP"]
    manage_py = find_manage_py()
    base_dir = str(SETTINGS['BASE_DIR'])
    
    if not commands:
        return

    logger.log(f"Running Django commands\n  └── {commands} \n", level=logger.DEBUG)
    
    for command in commands:
        command = command.strip()
        if command.startswith("collectstatic"):
            if command != "collectstatic --noinput":
                command = "collectstatic --noinput"
                logger.log(
                    "WARNING: collectstatic command should be run with --noinput flag. Running collectstatic "
                    "--noinput instead.",
                    level=logger.WARNING,
                )
        argv = [SETTINGS["PYTHON_PATH"], manage_py, *command.split(" ")]
        logger.log(f"Running command: {command}", level=logger.DEBUG)  # log command being run
        process = subprocess.run(argv, check=True, cwd=base_dir, env={**os.environ, "PYTHONPATH": add_to_pythonpath(base_dir)})
        logger.log_raw("\n")


def start_django_app(host_addr: str, port: int, uses_ipv6: bool = False):
    """
    Starts the Django application server.

    Args:
        host_addr (str): The host address to bind the server to.
        port (int): The port to bind the server to.
        uses_ipv6 (bool): Whether host on ipv6 address
    """
    manage_py = find_manage_py()
    base_dir = str(SETTINGS['BASE_DIR'])
    
    if uses_ipv6:
        host_addr = f"[{host_addr}]"
    
    argv = [
        SETTINGS["PYTHON_PATH"],
        manage_py,
        "runserver",
        f"{host_addr}:{port}",
        "--noreload",
    ]
    process = subprocess.Popen(argv, cwd=base_dir, env={**os.environ, "PYTHONPATH": add_to_pythonpath(base_dir)})
    return process
